[1,["14ZA8I5F1NNLRXXksmvoCb@6c48a","55DvZ3UgVLRJUQZtt8r9FB@f9941","55z3vjFZlDD7XV1JLI4I0i@f9941","3afkYhs8NLJZRtWm+kGBIZ@f9941","13wajD+8NJA6+BLdPeEu7j@f9941","2dTLrFyrFKn4zLt8D1cQEe","13wajD+8NJA6+BLdPeEu7j@6c48a","eaz5aort5LA7RCpCZIMLW2@6c48a","1bmiLemK1MJ7JWVejvluje@6c48a","3afkYhs8NLJZRtWm+kGBIZ@6c48a","43yCtRn69NbbgcgxASZ2IH@6c48a","46cJ1wwtBHBJIZAykpXR92@6c48a","55DvZ3UgVLRJUQZtt8r9FB@6c48a","55z3vjFZlDD7XV1JLI4I0i@6c48a","5cWA3fFVNJ74LqiKWHHEQ8@6c48a","43yCtRn69NbbgcgxASZ2IH@f9941","46cJ1wwtBHBJIZAykpXR92@f9941","18XcdlYV5FhYY4e0gIZ2s7@784fb","5cWA3fFVNJ74LqiKWHHEQ8@f9941","7eDdSSFSVDaKA/X7YvdT1z@d5570","70sWIR0SdKmrXGjeIAJ69P","a84xqNloVAJ5jFzp5Bt8iO@f9941","1bmiLemK1MJ7JWVejvluje@f9941","d8cjoq3Q9JmJCL/wAa9Jbx","baebW/QaNPZpA0wnUA6KU/","edI7yoOhBLmaE/r+W6UVQK","a84xqNloVAJ5jFzp5Bt8iO@6c48a","5aNxVe+pNHYbN1KP6oDXTt","8d0emafflFMofyEeARo+tT@6c48a","53WzStD/1HjYeFex2TuIu5"],["node","_textureSource","_spriteFrame","_normalMap","_parent","shadowMaterial","_effectAsset","_cameraComponent","dynamicShadowMapCamera","ambientShadowMapCamera","scene","_lightSpriteFrame","_defaultClip","_ambientShadowTexture","lightReceiverEffect","srcTexture"],["cc.SpriteFrame","cc.ImageAsset","cc.Texture2D",["cc.Node",["_name","_objFlags","_id","_layer","_components","_parent","_lpos","_children","_lscale"],-1,9,1,5,2,5],["cc.Camera",["_orthoHeight","_far","_visibility","_projection","_priority","_near","_fov","_clearFlags","_name","_color","node"],-6,5,1],["cc.UITransform",["_name","node","_contentSize"],2,1,5],["cc.Sprite",["_sizeMode","_isTrimmedMode","_type","node","_spriteFrame"],0,1,6],["cc.EffectAsset",["_name","shaders","techniques","combinations"],-1],["cc.Node",["_name","_objFlags","_parent","_components","_lpos"],1,1,12,5],["4ca56lcxBFIsY7PWrSDTLUX",["_receiveLayer","_normalMapOnOff","node","_normalMap"],1,1,6],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],["cc.SceneAsset",["_name"],2],["cc.Node",["_name","_objFlags","_parent","_components","_lpos"],1,1,2,5],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["083d8ftuS9OLodO1ov/lYhG",["_enabled","node"],2,1],["fe53c3SkKlJG5HxzWZ7vZv0",["node"],3,1],["cc.Canvas",["_name","node","_cameraComponent"],2,1,1],["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","node"],0,1],["3f8b2gb2MdDmLKfS4MVBLC+",["_lightToLayers","_intensity","_innerRadius","_outerRadius","_lightHeight","_radius","_falloffRange","_falloffExponent","_rectWidth","_rectHeight","node","_lightSpriteFrame"],-7,1,6],["3c690zIFo1HRYEnFXkZkt1n",["degSpeed","node","targetNode"],2,1,1],["cc.PolygonCollider2D",["_density","_sensor","node","_points"],1,1,12],["a99678uP4JBkJT9fuAgb40o",["node"],3,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.PrefabInfo",["root","asset","fileId","instance","nestedPrefabInstanceRoots","targetOverrides"],-3],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","skin","lightProbeInfo","postSettings"],3,4,4,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR"],2,5,5],["cc.ShadowsInfo",["_size"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",["_fogColor"],3,5],["cc.OctreeInfo",[],3],["cc.SkinInfo",[],3],["cc.LightProbeInfo",[],3],["cc.PostSettingsInfo",[],3],["5361drGw2JOv7sQ72w97yfU",["yFollow","node","targetNode"],2,1,1],["275c7r8NpJJ07cuaGDhSDvr",["node","cameraGame"],3,1,1],["364e94LpMpC+YCILKxxvY4A",["node","cameraGame"],3,1,1],["a4900fsVDxIMbuzfCJTkO8F",["_ambientIntensity","_ambienShadowAngle","_enableNormalMaps","_enableMaterialCache","_enableShadow","node","_ambientShadowColor","ambientShadowMapCamera","cameraGame","dynamicShadowMapCamera","_ambientShadowTexture","lightReceiverEffect"],-2,1,5,1,1,1,6,6],["4eb29g7LQJExqOvuzLQ6koN",["node","shadowMaterial"],3,1,6],["c3da3/S3WxOdYqUL9m2SWVE",["node","shadowMaterial"],3,1,6],["cc.PhysicsMaterial",["_name","_friction","_rollingFriction","_spinningFriction","_restitution"],-2],["cc.Material",["_name","_states","_defines","_props"],0,12],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[5,1,2,1],[6,0,1,3,4,3],[3,0,1,5,4,3],[9,0,1,2,3,3],[3,0,1,5,4,6,3],[7,0,1,2,4],[8,0,1,2,3,4,3],[5,1,1],[14,0,1,2],[40,0,1,2,3,4],[7,0,3,1,2,5],[11,0,2],[3,0,1,7,4,3],[3,0,1,3,2,7,4,6,5],[3,0,5,7,4,6,2],[3,0,1,2,7,4],[3,0,5,4,6,2],[3,0,5,4,6,8,2],[8,0,2,3,4,2],[12,0,1,2,3,4,3],[5,0,1,2,2],[6,0,3,4,2],[6,2,0,1,3,4,4],[13,0,1,2,3,2],[9,2,1],[15,0,1],[16,0,1,2,2],[17,0,1,2,3,4],[18,0,1,2,3,4,5,6,7,8,9,10,11,11],[19,0,1,2,2],[20,0,1,2,3,3],[21,0,1],[4,4,6,0,1,2,9,6],[4,3,4,0,1,7,2,10,9,7],[4,3,0,5,1,2,10,9,6],[4,8,3,0,5,1,2,10,9,7],[22,0,1,2,3,2],[23,0,1,2,3,4,5,7],[24,0,1,2,3,4,5,6,7,1],[25,0,1,2,2],[26,0,1],[27,1],[28,0,1],[29,1],[30,1],[31,1],[32,1],[33,0,1,2,2],[34,0,1,1],[35,0,1,1],[36,0,1,2,3,4,5,6,7,8,9,10,11,6],[37,0,1,1],[38,0,1,1],[39,0,1,2,3,4,6],[41,0,1],[42,0,1,2],[43,0,2],[44,0,1,2,3],[45,0,1,2],[10,0,2],[10,1,2,0,4]],[[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["13wajD+8NJA6+BLdPeEu7j"]}],[2],0,[],[],[]],[[{"name":"foreground_02_n","rect":{"x":0,"y":0,"width":1920,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1920,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-960,-540,0,960,-540,0,-960,540,0,960,540,0],"indexes":[0,1,2,2,1,3],"uv":[0,1080,1920,1080,0,0,1920,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-960,"y":-540,"z":0},"maxPos":{"x":960,"y":540,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[6]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["14ZA8I5F1NNLRXXksmvoCb"]}],[2],0,[],[],[]],[[{"name":"gecko_scaled","rect":{"x":256,"y":326,"width":247,"height":256},"offset":{"x":0,"y":0},"originalSize":{"width":247,"height":256},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[7]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["1bmiLemK1MJ7JWVejvluje"]}],[2],0,[],[],[]],[[{"name":"ambient-shadow-cicle","rect":{"x":0,"y":0,"width":256,"height":256},"offset":{"x":0,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-128,-128,0,128,-128,0,-128,128,0,128,128,0],"indexes":[0,1,2,2,1,3],"uv":[0,256,256,256,0,0,256,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-128,"y":-128,"z":0},"maxPos":{"x":128,"y":128,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[8]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["3afkYhs8NLJZRtWm+kGBIZ"]}],[2],0,[],[],[]],[[{"name":"foreground_02","rect":{"x":0,"y":0,"width":1920,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1920,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-960,-540,0,960,-540,0,-960,540,0,960,540,0],"indexes":[0,1,2,2,1,3],"uv":[0,1080,1920,1080,0,0,1920,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-960,"y":-540,"z":0},"maxPos":{"x":960,"y":540,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[9]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["43yCtRn69NbbgcgxASZ2IH"]}],[2],0,[],[],[]],[[{"name":"background_01","rect":{"x":0,"y":0,"width":1920,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1920,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-960,-540,0,960,-540,0,-960,540,0,960,540,0],"indexes":[0,1,2,2,1,3],"uv":[0,1080,1920,1080,0,0,1920,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-960,"y":-540,"z":0},"maxPos":{"x":960,"y":540,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[10]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["46cJ1wwtBHBJIZAykpXR92"]}],[2],0,[],[],[]],[[{"name":"gizmo_light","rect":{"x":0,"y":0,"width":128,"height":128},"offset":{"x":0,"y":0},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-64,-64,0,64,-64,0,-64,64,0,64,64,0],"indexes":[0,1,2,2,1,3],"uv":[0,128,128,128,0,0,128,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-64,"y":-64,"z":0},"maxPos":{"x":64,"y":64,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[11]],[[[5,"../Light2D/ambient-shadow",[{"hash":1206191742,"name":"../Light2D/ambient-shadow|unlit-vs:vert|unlit-fs:frag","blocks":[{"name":"params","stageFlags":1,"binding":0,"members":[{"name":"dirShadowOffsetX","type":13,"count":1},{"name":"dirShadowOffsetY","type":13,"count":1},{"name":"dirLightAngleSin","type":13,"count":1},{"name":"dirLightAngleCos","type":13,"count":1},{"name":"dirShadowScaleX","type":13,"count":1},{"name":"dirShadowScaleY","type":13,"count":1}],"defines":[]},{"name":"paramsFS","stageFlags":16,"binding":1,"members":[{"name":"dirShadowColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"srcTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_matWorld0","format":44,"isInstanced":true,"location":0,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":1,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":2,"defines":["USE_INSTANCING"]},{"name":"a_position","format":32,"location":3,"defines":[]},{"name":"a_texCoord","format":21,"location":4,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"params","stageFlags":1,"binding":0,"members":[{"name":"dirShadowOffsetX","type":13,"count":1},{"name":"dirShadowOffsetY","type":13,"count":1},{"name":"dirLightAngleSin","type":13,"count":1},{"name":"dirLightAngleCos","type":13,"count":1},{"name":"dirShadowScaleX","type":13,"count":1},{"name":"dirShadowScaleY","type":13,"count":1}],"defines":[]},{"name":"paramsFS","stageFlags":16,"binding":1,"members":[{"name":"dirShadowColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"srcTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nlayout(std140) uniform params{\n  float dirShadowOffsetX;\n  float dirShadowOffsetY;\n  float dirLightAngleSin;\n  float dirLightAngleCos;\n  float dirShadowScaleX;\n  float dirShadowScaleY;\n};\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nvec4 vert () {\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  v_uv= a_texCoord;\n  vec4 originalPosition = vec4(a_position.x*dirShadowScaleX,a_position.y*dirShadowScaleY,a_position.z , 1.0);\n  vec3 lightDirection = vec3(-dirLightAngleCos, 1.0, dirLightAngleSin);\n  vec3 lightDirectionNormal = normalize(lightDirection);\n  vec4 worldPos = matWorld * originalPosition;\n  vec4 centerPoint = vec4(0, 0, 0, 1);\n  centerPoint = matWorld * centerPoint;\n  vec3 shadowCenter = centerPoint.xyz;\n  vec3 normalVec = normalize(vec3(0, 1.0,0.5));\n  vec3 pointOnPlane = shadowCenter;\n  vec3 toPlane = pointOnPlane - worldPos.xyz;\n  toPlane.z = 0.0;\n  float projectionDistance = dot(toPlane, normalVec) / dot(lightDirectionNormal, normalVec);\n  vec4 pos = worldPos;\n  pos.xyz += projectionDistance * lightDirectionNormal;\n  pos.xyz += vec3(dirShadowOffsetX, dirShadowOffsetY, 0.0);\n  return  cc_matProj * cc_matView   *  pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nin vec2 v_uv;\nuniform sampler2D srcTexture;\nlayout(std140) uniform paramsFS {\n  vec4 dirShadowColor;\n};\nvec4 frag () {\n  vec4 col=texture(srcTexture,v_uv);\n  vec4 result = vec4(1.0,1.0,1.0,col.a) * dirShadowColor;\n  return result;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\n    uniform float dirShadowOffsetX;\n    uniform float dirShadowOffsetY;\n    uniform float dirLightAngleSin;\n    uniform float dirLightAngleCos;\n    uniform float dirShadowScaleX;\n    uniform float dirShadowScaleY;\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nvec4 vert () {\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  v_uv= a_texCoord;\n  vec4 originalPosition = vec4(a_position.x*dirShadowScaleX,a_position.y*dirShadowScaleY,a_position.z , 1.0);\n  vec3 lightDirection = vec3(-dirLightAngleCos, 1.0, dirLightAngleSin);\n  vec3 lightDirectionNormal = normalize(lightDirection);\n  vec4 worldPos = matWorld * originalPosition;\n  vec4 centerPoint = vec4(0, 0, 0, 1);\n  centerPoint = matWorld * centerPoint;\n  vec3 shadowCenter = centerPoint.xyz;\n  vec3 normalVec = normalize(vec3(0, 1.0,0.5));\n  vec3 pointOnPlane = shadowCenter;\n  vec3 toPlane = pointOnPlane - worldPos.xyz;\n  toPlane.z = 0.0;\n  float projectionDistance = dot(toPlane, normalVec) / dot(lightDirectionNormal, normalVec);\n  vec4 pos = worldPos;\n  pos.xyz += projectionDistance * lightDirectionNormal;\n  pos.xyz += vec3(dirShadowOffsetX, dirShadowOffsetY, 0.0);\n  return  cc_matProj * cc_matView   *  pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvarying vec2 v_uv;\nuniform sampler2D srcTexture;\n   uniform vec4 dirShadowColor;\nvec4 frag () {\n  vec4 col=texture2D(srcTexture,v_uv);\n  vec4 result = vec4(1.0,1.0,1.0,col.a) * dirShadowColor;\n  return result;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":62,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":1}},"defines":[{"name":"USE_INSTANCING","type":"boolean"}]}],[{"name":"opaque","passes":[{"program":"../Light2D/ambient-shadow|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"dirLightAngleSin":{"type":13,"value":[0]},"dirLightAngleCos":{"type":13,"value":[0]},"dirShadowOffsetX":{"type":13,"value":[0]},"dirShadowOffsetY":{"type":13,"value":[0]},"dirShadowScaleX":{"type":13,"value":[1]},"dirShadowScaleY":{"type":13,"value":[1]},"dirShadowColor":{"type":16,"value":[0,0,0,0.6]},"srcTexture":{"value":"white","type":28}}}]}]]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["55DvZ3UgVLRJUQZtt8r9FB"]}],[2],0,[],[],[]],[[{"name":"foreground_01","rect":{"x":0,"y":0,"width":1920,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1920,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-960,-540,0,960,-540,0,-960,540,0,960,540,0],"indexes":[0,1,2,2,1,3],"uv":[0,1080,1920,1080,0,0,1920,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-960,"y":-540,"z":0},"maxPos":{"x":960,"y":540,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[12]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["55z3vjFZlDD7XV1JLI4I0i"]}],[2],0,[],[],[]],[[{"name":"foreground_01_n","rect":{"x":0,"y":0,"width":1920,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1920,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-960,-540,0,960,-540,0,-960,540,0,960,540,0],"indexes":[0,1,2,2,1,3],"uv":[0,1080,1920,1080,0,0,1920,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-960,"y":-540,"z":0},"maxPos":{"x":960,"y":540,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[13]],[[[5,"../Light2D/light-shadow-mesh",[{"hash":1377376679,"name":"../Light2D/light-shadow-mesh|mesh-vs:vert|mesh-fs:frag","blocks":[{"name":"PARAMS","stageFlags":16,"binding":0,"members":[{"name":"color","type":16,"count":1},{"name":"sourceId","type":13,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["USE_LOCAL"]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"PARAMS","stageFlags":16,"binding":0,"members":[{"name":"color","type":16,"count":1},{"name":"sourceId","type":13,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nin vec3 a_position;\nout vec3 fragPos;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    fragPos = (cc_matWorld * pos).xyz;\n    pos = cc_matWorld * pos;\n  #else\n    fragPos = a_position;\n  #endif\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  in vec3 fragPos;\n    layout(std140) uniform PARAMS{\n    vec4 color;\n    float sourceId;\n  };\n  vec4 setBitmask(float id) {\n      int idx = int(id);\n      int channel = idx / 8;\n      int bit = idx - channel * 8;\n      int mask = 1 << bit;\n      float v = float(mask) / 255.0;\n      if (channel == 0) return vec4(v, 0.0, 0.0, 0.0);\n      if (channel == 1) return vec4(0.0, v, 0.0, 0.0);\n      if (channel == 2) return vec4(0.0, 0.0, v, 0.0);\n      if (channel == 3) return vec4(0.0, 0.0, 0.0, v);\n      return vec4(0.0);\n  }\n  vec4 frag () {\n    if(sourceId < 0.0) return vec4(0.0);\n    return setBitmask(sourceId);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nvarying vec3 fragPos;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    fragPos = (cc_matWorld * pos).xyz;\n    pos = cc_matWorld * pos;\n  #else\n    fragPos = a_position;\n  #endif\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  varying vec3 fragPos;\n           uniform float sourceId;\n  vec4 setBitmask(float id) {\n    int idx = int(id);\n    int channel = idx / 8;\n    int bit = idx -  channel* 8;\n    float v = pow(2.0, float(bit)) / 255.0;\n    if (channel == 0) return vec4(v, 0.0, 0.0, 0.0);\n    if (channel == 1) return vec4(0.0, v, 0.0, 0.0);\n    if (channel == 2) return vec4(0.0, 0.0, v, 0.0);\n    if (channel == 3) return vec4(0.0, 0.0, 0.0, v);\n    return vec4(0.0);\n  }\n  vec4 frag () {\n    if(sourceId < 0.0) return vec4(0.0);\n    return setBitmask(sourceId);\n  }\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":56,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":2}},"defines":[{"name":"USE_LOCAL","type":"boolean"}]}],[{"passes":[{"program":"../Light2D/light-shadow-mesh|mesh-vs:vert|mesh-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"color":{"type":16,"value":[0,0,0,1]},"sourceId":{"type":13,"value":[0]}}}]}]]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["5cWA3fFVNJ74LqiKWHHEQ8"]}],[2],0,[],[],[]],[[{"name":"woodbox","rect":{"x":0,"y":0,"width":256,"height":256},"offset":{"x":0,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-128,-128,0,128,-128,0,-128,128,0,128,128,0],"indexes":[0,1,2,2,1,3],"uv":[0,256,256,256,0,0,256,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-128,"y":-128,"z":0},"maxPos":{"x":128,"y":128,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[14]],[[{"name":"character/03","rect":{"x":252,"y":500,"width":168,"height":506},"offset":{"x":2,"y":-13},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[{"name":"character/05","rect":{"x":2,"y":1544,"width":178,"height":502},"offset":{"x":4,"y":-14},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[{"name":"character/07","rect":{"x":2,"y":1032,"width":178,"height":510},"offset":{"x":2,"y":-13},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[{"name":"character/08","rect":{"x":2,"y":2,"width":176,"height":514},"offset":{"x":-9,"y":-15},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[{"name":"character/04","rect":{"x":182,"y":1032,"width":158,"height":508},"offset":{"x":0,"y":-9},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[{"name":"character/02","rect":{"x":180,"y":2,"width":234,"height":496},"offset":{"x":3,"y":-12},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[{"name":"character/01","rect":{"x":2,"y":518,"width":248,"height":512},"offset":{"x":17,"y":-15},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[{"name":"character/06","rect":{"x":182,"y":1542,"width":202,"height":504},"offset":{"x":7,"y":-17},"originalSize":{"width":650,"height":650},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[],"indexes":[],"uv":[],"nuv":[],"minPos":{"x":0,"y":0,"z":0},"maxPos":{"x":0,"y":0,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[0]],[[[11,"scene_tutorial"],[12,"gameobjects",512,[-2,-3,-4,-5,-6,-7,-8,-9],[[7,-1]]],[4,"role",512,1,[[0,-10,[5,650,650]],[1,2,false,-11,12],[23,true,-12,[13,14],15],[3,2,true,-13,16],[8,false,-14],[25,-15]],[1,221.546,-94.193,0]],[13,"Canvas",512,33554432,"413H3RD/hM4bdzWvWyxS03",[-20,-21,1],[[20,"Canvas<UITransform>",-16,[5,1920.0000000000002,1080]],[26,"Canvas<Canvas>",-18,-17],[27,45,1280,720,-19]],[1,960.0000000000001,540,0]],[14,"light_point",1,[-26],[[0,-22,[5,1800,1800]],[28,2,2,4,900,100,4,887,1,382,13.4,-23,8],[8,false,-24],[29,60,-25,2]],[1,538.702,194.067,0]],[15,"LightSystemKeep",512,"7clpsZ2k9LF6qis5csfBK9",[-27,-28,-29,-30,-31]],[16,"woodbox",1,[[7,-32],[30,0,true,-33,[[[0,-49.609375,50],[0,-50,-49.609375],[0,50,-49.609375],[0,50,49.609375]],8,8,8,8]],[31,-34],[21,0,-35,9]],[1,1348.841,-328.389,0]],[32,1,37.571,540,2343.4,1073741824,[4,4278190080]],[17,"background",1,[[0,-36,[5,6350.643,1080]],[22,2,0,false,-37,0],[24,-38]],[1,1624.679,172.271,-1006.935],[1,1.4,1.4,1]],[2,"foreground_01",512,1,[[0,-39,[5,1920,1080]],[1,2,false,-40,1],[3,2,true,-41,2]]],[4,"foreground_02",512,1,[[0,-42,[5,1920,1080]],[1,2,false,-43,3],[3,2,true,-44,4]],[1,1920,0,0]],[4,"foreground_03",512,1,[[0,-45,[5,1920,1080]],[1,2,false,-46,5],[3,2,true,-47,6]],[1,3840,0,0]],[4,"foreground_04",512,1,[[0,-48,[5,1920,1080]],[1,2,false,-49,10],[3,2,true,-50,11]],[1,-1920,0,0]],[36,"scene_tutorial",[3,5],[37,null,null,"50d8585d-6e58-4e73-8143-284b17101ae5",null,null,[]],[38,[39,0.78125,[2,0.2,0.5019607843137255,0.8,0.520833125],[2,0.2,0.5019607843137255,0.8,0.520833125]],[40,[0,512,512]],[41],[42,[4,4292993505]],[43],[44],[45],[46]]],[18,"Camera_GAME",3,[[7,[47,false,-51,2]],1,4],[1,-344.014,-82.852,1276.502]],[2,"gizmo_light",512,4,[[0,-52,[5,80,80]],[1,0,false,-53,7]]],[6,"Light2DAmbientShadowCamera",512,5,[[-54,[48,-55,7]],1,4],[1,960,540,1000]],[6,"Light2DShadowCamera",512,5,[[-56,[49,-57,7]],1,4],[1,960,540,0]],[19,"Camera_UI",512,3,[-58],[1,0,0,1000]],[33,0,2,591.7887154861945,2000,0,311427072,18,[4,4294967295]],[2,"Lighting2DSystem",512,5,[[50,0.38,148.6,true,false,true,-61,[4,2684354560],-60,7,-59,17,18]]],[34,0,540,0,2000,2,16,[4,4294967295]],[35,"Camera<CameraComponent>",0,540,0,2000,1,17,[4,4278190080]],[2,"Light2DShadow",512,5,[[51,-62,19]]],[2,"Light2dAmbientShadow",512,5,[[52,-63,20]]]],0,[0,0,1,0,-1,8,0,-2,9,0,-3,10,0,-4,11,0,-5,4,0,-6,2,0,-7,6,0,-8,12,0,0,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,3,0,7,19,0,0,3,0,0,3,0,-1,18,0,-2,14,0,0,4,0,0,4,0,0,4,0,0,4,0,-1,15,0,-1,20,0,-2,23,0,-3,17,0,-4,24,0,-5,16,0,0,6,0,0,6,0,0,6,0,0,6,0,0,8,0,0,8,0,0,8,0,0,9,0,0,9,0,0,9,0,0,10,0,0,10,0,0,10,0,0,11,0,0,11,0,0,11,0,0,12,0,0,12,0,0,12,0,0,14,0,0,15,0,0,15,0,-1,21,0,0,16,0,-1,22,0,0,17,0,-1,19,0,8,22,0,9,21,0,0,20,0,0,23,0,0,24,0,10,13,1,4,3,3,4,13,5,4,13,7,0,14,63],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,2,3,2,3,2,11,2,2,3,2,-1,-2,12,3,13,14,5,5],[15,1,2,3,4,1,2,16,17,18,3,4,19,5,20,5,21,22,23,24,25]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["8d0emafflFMofyEeARo+tT"]}],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["a84xqNloVAJ5jFzp5Bt8iO"]}],[2],0,[],[],[]],[[{"name":"spritesheet_n","rect":{"x":0,"y":0,"width":422,"height":2048},"offset":{"x":0,"y":0},"originalSize":{"width":422,"height":2048},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-211,-1024,0,211,-1024,0,-211,1024,0,211,1024,0],"indexes":[0,1,2,2,1,3],"uv":[0,2048,422,2048,0,0,422,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-211,"y":-1024,"z":0},"maxPos":{"x":211,"y":1024,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[1],[26]],[[[53,"default-physics-material",0.8,0.1,0.1,0.1]],0,0,[],[],[]],[[[9,"light-shadow-mesh",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"color",8,[4,4294967295]]],11]]],0,0,[0],[6],[27]],[[[10,"../Light2D/light-receiver",[{}],[{"hash":2007853853,"name":"../Light2D/light-receiver|sprite-vs:vert|sprite-fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"LightUniforms","stageFlags":16,"binding":1,"members":[{"name":"lightPositionsArr","type":16,"count":20},{"name":"lightColorsArr","type":16,"count":20},{"name":"lightParamsArr","type":16,"count":20},{"name":"customTextureIndexArr","type":16,"count":4},{"name":"lightExtraDataArr","type":16,"count":20},{"name":"lightExtraDataArr2","type":16,"count":20},{"name":"lightExtraDataArr3","type":16,"count":20},{"name":"customArr","type":16,"count":64},{"name":"shadowMaskArea","type":16,"count":1},{"name":"shadowMaskOffset","type":16,"count":1},{"name":"ambientColor","type":16,"count":1},{"name":"ambientShadowMaskArea","type":16,"count":1},{"name":"ambientShadowOnOff","type":13,"count":1},{"name":"ambientIntensity","type":13,"count":1},{"name":"ambientOnOffResult","type":13,"count":1},{"name":"useNormalMap","type":13,"count":1},{"name":"lightCount","type":13,"count":1},{"name":"lightOnOff","type":13,"count":1},{"name":"shadowOnOff","type":13,"count":1},{"name":"inEditMode","type":13,"count":1},{"name":"customPolygonCount","type":13,"count":1},{"name":"useAlphaHeight","type":13,"count":1},{"name":"baseHeight","type":13,"count":1},{"name":"heightScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shadowMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":[]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":[]},{"name":"spriteLightTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":[]},{"name":"ambientShadowMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]},{"name":"a_color2","format":44,"location":3,"defines":["TWO_COLORED"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"LightUniforms","stageFlags":16,"binding":1,"members":[{"name":"lightPositionsArr","type":16,"count":20},{"name":"lightColorsArr","type":16,"count":20},{"name":"lightParamsArr","type":16,"count":20},{"name":"customTextureIndexArr","type":16,"count":4},{"name":"lightExtraDataArr","type":16,"count":20},{"name":"lightExtraDataArr2","type":16,"count":20},{"name":"lightExtraDataArr3","type":16,"count":20},{"name":"customArr","type":16,"count":64},{"name":"shadowMaskArea","type":16,"count":1},{"name":"shadowMaskOffset","type":16,"count":1},{"name":"ambientColor","type":16,"count":1},{"name":"ambientShadowMaskArea","type":16,"count":1},{"name":"ambientShadowOnOff","type":13,"count":1},{"name":"ambientIntensity","type":13,"count":1},{"name":"ambientOnOffResult","type":13,"count":1},{"name":"useNormalMap","type":13,"count":1},{"name":"lightCount","type":13,"count":1},{"name":"lightOnOff","type":13,"count":1},{"name":"shadowOnOff","type":13,"count":1},{"name":"inEditMode","type":13,"count":1},{"name":"customPolygonCount","type":13,"count":1},{"name":"useAlphaHeight","type":13,"count":1},{"name":"baseHeight","type":13,"count":1},{"name":"heightScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shadowMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":[]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":[]},{"name":"spriteLightTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":[]},{"name":"ambientShadowMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\n#if SAMPLE_FROM_RT\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define REFLECTION_PROBE_TYPE_BLEND 3\n  #define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n      #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_SPHERE 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define LIGHT_TYPE_POINT 3.0\n  #define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n  #define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n  #define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n  #define TONE_MAPPING_ACES 0\n  #define TONE_MAPPING_LINEAR 1\n  #define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n  #ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n    #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n  #endif\n  #ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n  #endif\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\n#if TWO_COLORED\n  in vec4 a_color2;\n#endif\nout vec4 v_color;\n#if TWO_COLORED\n  out vec4 v_dark;\n#endif\nout vec4 color;\nout vec2 uv0;\nout vec3 worldPos;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    worldPos = (cc_matWorld * pos).xyz;\n    pos = cc_matWorld * pos;\n  #else\n    worldPos = a_position;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n #if TWO_COLORED\n    v_dark = a_color2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  vec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n  #if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n  #else\n    return texture(tex, uv);\n  #endif\n  }\n  #if USE_ALPHA_TEST\n    layout(std140) uniform ALPHA_TEST_DATA {\n      float alphaThreshold;\n    };\n  #endif\n  void ALPHA_TEST (in vec4 color) {\n    #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n    #endif\n  }\n  void ALPHA_TEST (in float alpha) {\n    #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n    #endif\n  }\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_probeInfo;\n    mediump vec4 cc_debug_view_mode;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  in vec4 color;\n  in vec3 worldPos;\n  in vec2 uv0;\n  #if TWO_COLORED\n    in vec4 v_dark;\n  #endif\n  int _fragLighted = 0;\n  uniform sampler2D shadowMap;\n  uniform sampler2D normalMap;\n  uniform sampler2D spriteLightTexture;\n  uniform sampler2D ambientShadowMap;\n  layout(std140) uniform LightUniforms {\n    vec4  lightPositionsArr[20];\n    vec4  lightColorsArr[20];\n    vec4  lightParamsArr[20];\n    vec4  customTextureIndexArr[16/4];\n    vec4  lightExtraDataArr[20];\n    vec4  lightExtraDataArr2[20];\n    vec4  lightExtraDataArr3[20];\n    vec4  customArr[64];\n     vec4 shadowMaskArea;\n     vec4 shadowMaskOffset;\n     vec4 ambientColor;\n    vec4 ambientShadowMaskArea;\n    float  ambientShadowOnOff;\n     float ambientIntensity;\n     float ambientOnOffResult;\n     float useNormalMap;\n     float lightCount;\n     float lightOnOff;\n     float  shadowOnOff;\n     float  inEditMode;\n     float customPolygonCount;\n     float useAlphaHeight;\n     float baseHeight;\n     float heightScale;\n  };\n    uniform sampler2D cc_spriteTexture;\n  float intPow10(float base, float fexp) {\n    float t1 = clamp(fexp, 0.0, 10.0);\n    int exponent = int(t1);\n    float powers[11];\n    powers[0] = 1.0;\n    powers[1] = base;\n    float b2 = base * base;\n    powers[2] = b2;\n    float b3 = b2 * base;\n    powers[3] = b3;\n    float b4 = b2 * b2;\n    powers[4] = b4;\n    powers[5] = b4 * base;\n    powers[6] = b4 * b2;\n    powers[7] = b4 * b3;\n    powers[8] = b4 * b4;\n    powers[9] = b4 * b4 * base;\n    powers[10] = b4 * b4 * b2;\n    return powers[exponent];\n  }\n  float normalizeDeg(float deg) {\n    return mod(mod(deg + 180.0, 360.0) + 360.0, 360.0) - 180.0;\n  }\n  bool inAngleRange(float deg, float start, float end) {\n    float r = mod(end - start + 360.0, 360.0);\n    if (abs(end - start) >= 359.99) return true;\n    float d = mod(deg - start + 360.0, 360.0);\n    return d <= r;\n  }\n  bool isFLoatEqual(float a, float b) {\n      return abs(a - b) < 1e-4;\n  }\nfloat calculateEffectiveHeight(vec3 normalVec, vec4 normalData) {\n    float effectiveReceiverHeight = baseHeight;\n    if (useAlphaHeight > 0.5) {\n        float alphaHeight = (normalData.a - 0.5) * heightScale;\n        effectiveReceiverHeight = baseHeight + alphaHeight;\n    } else {\n        float surfaceHeightOffset = (normalVec.z - 1.0) * heightScale;\n        effectiveReceiverHeight = baseHeight + surfaceHeightOffset;\n    }\n    return effectiveReceiverHeight;\n}\nfloat calculate3DLighting(vec3 normalVec, vec2 relPx, float effectiveReceiverHeight, float lightHeight) {\n    vec3 lightToFrag = vec3(relPx.x, relPx.y, effectiveReceiverHeight - lightHeight);\n    vec3 lightDir = normalize(-lightToFrag);\n    return max(0.0, dot(normalize(normalVec), lightDir));\n}\n  vec3 calculatePointLight(\n      vec3 normalVec,\n      vec4 normalData,\n      vec3 baseColor,\n      vec3 fragWorldPos,\n      vec4 lightPosData,\n      vec4 lightColorData,\n      vec4 lightParamData,\n      vec4 lightExtraData,\n      vec4 lightExtraData2,\n      vec4 lightExtraData3\n  ) {\n      vec3 lightWorldPos = lightPosData.xyz;\n      vec3 lightColor = lightColorData.rgb;\n      float intensity = lightParamData.x;\n      float blendMode = lightParamData.y;\n      float falloff = lightExtraData.w;\n      float innerRadius = lightExtraData.x;\n      float innerAngleStart = lightExtraData.y;\n      float innerAngleEnd = lightExtraData.z;\n      float outerAngleStart = lightExtraData2.x;\n      float outerAngleEnd = lightExtraData2.y;\n      float outerRadius = lightExtraData2.z;\n      vec2 relPxOri = fragWorldPos.xy - lightWorldPos.xy;\n      float distPx = dot(relPxOri, relPxOri);\n      if (distPx > outerRadius * outerRadius) {\n        return vec3(0.0);\n      }\n      float cosA = lightExtraData3.x;\n      float sinA = lightExtraData3.y;\n      vec2 relPx = vec2(\n        dot(relPxOri, vec2(cosA, -sinA)),\n        dot(relPxOri, vec2(sinA, cosA))\n      );\n      float t = 1.0;\n      if (distPx > innerRadius * innerRadius) {\n        float dis = sqrt(distPx);\n        t = 1.0 - smoothstep(innerRadius, outerRadius, dis);\n        t = intPow10(t, falloff);\n      }\n      float angle = atan(relPx.y, relPx.x);\n      float deg = degrees(angle);\n      deg = normalizeDeg(deg);\n      float aInnerStart = degrees(innerAngleStart);\n      float aInnerEnd = degrees(innerAngleEnd);\n      float aOuterStart = degrees(outerAngleStart);\n      float aOuterEnd =degrees (outerAngleEnd);\n      if(!inAngleRange(deg, aOuterStart, aOuterEnd)) {\n        return vec3(0.0);\n      }\n      float angleAtten = 0.0;\n      float totalAngle = abs(aOuterEnd - aOuterStart);\n      if (totalAngle >= 360.0) {\n        angleAtten = 1.0;\n      } else if (inAngleRange(deg, aInnerStart, aInnerEnd)) {\n        angleAtten = 1.0;\n      } else if (inAngleRange(deg, aOuterStart, aInnerStart)) {\n        float edgeLen = mod(aInnerStart - aOuterStart + 360.0, 360.0);\n        float s = mod(deg - aOuterStart + 360.0, 360.0) / edgeLen;\n        angleAtten = intPow10(s, falloff);\n      } else if (inAngleRange(deg, aInnerEnd, aOuterEnd)) {\n        float edgeLen = mod(aOuterEnd - aInnerEnd + 360.0, 360.0);\n        float s = mod(aOuterEnd - deg + 360.0, 360.0) / edgeLen;\n        angleAtten = intPow10(s, falloff);\n      } else {\n        angleAtten = 0.0;\n      }\n      float attenuation = t * angleAtten;\n      if (attenuation <= 0.001) {\n        return vec3(0.0);\n      };\n    _fragLighted = 1;\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation * intensity;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relPxOri, effectiveReceiverHeight, lightHeight);\n    return baseColor*lightColor * attenuation * diffuse * intensity;\n  }\n  float sdPolygon(vec2 p, float radius, float sides) {\n    float sideCount = max(3.0, floor(sides + 0.5));\n    float angleStep = 6.2831853 / sideCount;\n    float a = atan(p.y, p.x) + 3.1415926;\n    float r = length(p);\n    float segmentAngle = floor((a + angleStep * 0.5) / angleStep) * angleStep;\n    float distToEdge = r * cos(segmentAngle - a) - radius * cos(angleStep * 0.5);\n    float distToVertex = r - radius;\n    return max(distToEdge, distToVertex);\n  }\n  vec3 calculateParametricRegularPolygon(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 lightExtraData,vec4 lightExtraData2) {\n    vec3 lightPos = lightPosData.xyz;\n    vec3 lightColor = lightColorData.rgb;\n    float intensity = lightParamData.x;\n    float radius = max(0.1, lightExtraData.x);\n    float sides = max(3.0, lightExtraData.y);\n    float falloffRange = lightExtraData2.y;\n    float  falloffExponent = lightExtraData2.x;\n    vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n    float cosA = lightExtraData.z;\n    float sinA = lightExtraData.w;\n    vec2 rel = vec2(\n      dot(relativePos, vec2(cosA, -sinA)),\n      dot(relativePos, vec2(sinA, cosA))\n    );\n    float dist = length(rel);\n    float attenuationDistance =  falloffRange;\n    if (dist > (radius + attenuationDistance)) return vec3(0.0);\n    float sdDist = sdPolygon(rel, radius, sides);\n    float attenuation = 0.0;\n    if (sdDist <= 0.0) {\n      attenuation = intensity;\n    } else if (sdDist < attenuationDistance) {\n      float normalizedDist = sdDist / attenuationDistance;\n      float t = intPow10(1.0 - normalizedDist, falloffExponent);\n      attenuation = intensity * clamp(t, 0.0, 1.0);\n    }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n    return baseColor*lightColor * attenuation * diffuse;\n  }\n  float sdBox( vec2 p, vec2 b )\n  {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n  }\n  vec3 calculateParametricRectangleLight(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 lightExtraData,vec4 lightExtraData2) {\n      vec3 lightPos = lightPosData.xyz;\n      vec3 lightColor = lightColorData.rgb;\n      float intensity = lightParamData.x;\n      float width = max(0.1, lightExtraData.x);\n      float height = max(0.1, lightExtraData.y);\n      float falloffRange = lightExtraData2.y;\n      float falloffExponent = lightExtraData2.x;\n      vec2 halfSize = vec2(width * 0.5, height * 0.5);\n      vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n      float cosA = lightExtraData.z;\n      float sinA = lightExtraData.w;\n      vec2 rel = vec2(\n          dot(relativePos, vec2(cosA, -sinA)),\n          dot(relativePos, vec2(sinA, cosA))\n      );\n      float attenuationDistance =  falloffRange;\n      float maxDist = length(halfSize) + attenuationDistance;\n      if (length(rel) > maxDist) return vec3(0.0);\n      float sdDist = sdBox(rel, halfSize);\n      float attenuation = 0.0;\n      if (sdDist <= 0.0) {\n        attenuation = intensity;\n      } else if (sdDist < attenuationDistance) {\n        float normalizedDist = sdDist / attenuationDistance;\n        float t = intPow10(1.0 - normalizedDist,falloffExponent);\n        attenuation = intensity * clamp(t, 0.0, 1.0);\n      }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n      return baseColor * lightColor * attenuation * diffuse;\n  }\n  vec3 calculateParametricCircleLight(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 lightExtraData,vec4 lightExtraData2) {\n      vec3 lightPos = lightPosData.xyz;\n      vec3 lightColor = lightColorData.rgb;\n      float intensity = lightParamData.x;\n      float radius = max(0.1, lightExtraData.x);\n      float falloffRange = lightExtraData2.y;\n      float falloffExponent = lightExtraData2.x;\n      float cosA = lightExtraData.z;\n      float sinA = lightExtraData.w;\n      vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n      vec2 rel = vec2(\n          dot(relativePos, vec2(cosA, -sinA)),\n          dot(relativePos, vec2(sinA, cosA))\n      );\n      float dist = length(rel);\n      float attenuationDistance =  falloffRange;\n      float maxDist = radius + attenuationDistance;\n      if (dist > maxDist) return vec3(0.0);\n      float attenuation = 0.0;\n      if (dist <= radius) {\n        attenuation = intensity;\n      } else if (dist < maxDist) {\n        float normalizedDist = (dist - radius) / attenuationDistance;\n        float t = intPow10(1.0 - normalizedDist, falloffExponent);\n        attenuation = intensity * clamp(t, 0.0, 1.0);\n      }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n      return baseColor * lightColor * attenuation * diffuse;\n  }\nfloat sdOptimizedPolygon(vec2 p, vec4 precomputedData[4], int pointCount) {\n    float minDistSq = 1e20;\n    int windingNumber = 0;\n    int maxIter = min(pointCount, 4);\n    for (int i = 0; i < maxIter; ++i) {\n        vec4 data = precomputedData[i];\n        vec2 a = data.xy;\n        vec2 edgeVec = data.zw;\n        vec2 b = a + edgeVec;\n        vec2 pa = p - a;\n        float edgeLengthSq = dot(edgeVec, edgeVec);\n        if (edgeLengthSq > 0.0) {\n            float h = clamp(dot(pa, edgeVec) / edgeLengthSq, 0.0, 1.0);\n            vec2 closest = pa - edgeVec * h;\n            minDistSq = min(minDistSq, dot(closest, closest));\n        }\n        if (a.y <= p.y) {\n            if (b.y > p.y) {\n                float cross = edgeVec.x * (p.y - a.y) - edgeVec.y * (p.x - a.x);\n                windingNumber += (cross > 0.0) ? 1 : 0;\n            }\n        } else {\n            if (b.y <= p.y) {\n                float cross = edgeVec.x * (p.y - a.y) - edgeVec.y * (p.x - a.x);\n                windingNumber += (cross < 0.0) ? 1 : 0;\n            }\n        }\n    }\n    float minDist = sqrt(minDistSq);\n    return (windingNumber & 1) != 0 ? -minDist : minDist;\n}\nvec3 calculateParametricCustomPolygon(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 extraPackedData, vec4 precomputedPoints[4],vec4 extraData2) {\n    int pointCount = int(extraPackedData.x);\n    float falloffRange = extraPackedData.y;\n    float falloffExponent = extraPackedData.z;\n    if (pointCount < 3) return vec3(0.0);\n    vec3 lightPos = lightPosData.xyz;\n    vec3 lightColor = lightColorData.rgb;\n    float intensity = lightParamData.x;\n    vec2 center = vec2(extraData2.z,extraData2.w);\n    vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n    float cosA = extraData2.x;\n    float sinA = extraData2.y;\n    vec2 fragLocalPos = vec2(\n        dot(relativePos, vec2(cosA, -sinA)),\n        dot(relativePos, vec2(sinA, cosA))\n    );\n    float maxRadius = extraPackedData.w +falloffRange ;\n    vec2 disv = fragLocalPos-center;\n    if ((disv.x*disv.x+disv.y*disv.y) > maxRadius*maxRadius) return vec3(0.0);\n    vec2 checkLocalPos = fragLocalPos;\n    bool quickInside = false;\n    for (int k = 0; k < 4; ++k) {\n      if (k >= pointCount) break;\n      vec2 a = precomputedPoints[k].xy;\n      vec2 b = a + vec2(precomputedPoints[k].z, precomputedPoints[k].w);\n      if (((a.y <= checkLocalPos.y) && (b.y > checkLocalPos.y)) ||\n        ((a.y > checkLocalPos.y) && (b.y <= checkLocalPos.y))) {\n        float crossProduct = (b.x - a.x) * (checkLocalPos.y - a.y) - (b.y - a.y) * (checkLocalPos.x - a.x);\n        if (a.y < b.y) {\n          quickInside = quickInside != (crossProduct > 0.0);\n        } else {\n          quickInside = quickInside != (crossProduct < 0.0);\n        }\n      }\n    }\n    bool isRangeZero = (falloffRange<1.0);\n    float sdDist =  0.0;\n    if(quickInside){\n      sdDist = 0.0;\n    }else{\n      if(isRangeZero){\n        sdDist  = falloffRange + 1.0;\n      }else{\n        sdDist = sdOptimizedPolygon(fragLocalPos, precomputedPoints, pointCount);\n      }\n    }\n    float attenuation= 1.0;\n    if (sdDist <= 0.0) {\n        attenuation = intensity;\n    } else if (sdDist < falloffRange) {\n        float normalizedDist = sdDist / falloffRange;\n        float t= intPow10(1.0 - normalizedDist, falloffExponent);\n        attenuation = intensity * clamp(t, 0.0, 1.0);\n    } else {\n        return vec3(0.0);\n    }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n    return baseColor * lightColor * attenuation * diffuse;\n}\n vec3 calculateSpriteLight(vec3 normalVec, vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData,vec4 lightExtraData,vec4 lightExtraData2,vec4 lightExtraData3) {\n    vec3 lightPos = lightPosData.xyz;\n    vec3 lightColor = lightColorData.rgb;\n    float intensity = lightParamData.x;\n    float cosA = lightExtraData.x;\n    float sinA = lightExtraData.y;\n    float rangeX = lightExtraData.z;\n    float rangeY = lightExtraData.w;\n    if (rangeX < 0.0001 || rangeY < 0.0001) return vec3(0.0);\n    vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n    float maxRange = max(rangeX, rangeY);\n    if (dot(relativePos, relativePos) > maxRange * maxRange ) return vec3(0.0);\n    vec2 rel = vec2(\n        dot(relativePos, vec2(cosA, -sinA)),\n        dot(relativePos, vec2(sinA, cosA))\n    );\n    vec2 halfSizeSelf = vec2(rangeX * 0.5, rangeY * 0.5) ;\n    if(abs(rel.x) > halfSizeSelf.x || abs(rel.y) > halfSizeSelf.y) return vec3(0.0);\n    vec2 spriteUV = rel*vec2(1.0/rangeX,1.0/rangeY) + 0.5;\n    vec2 uvOrigin = lightExtraData2.xy;\n    vec2 uvSize = lightExtraData2.zw;\n    vec2 atlasUV = uvOrigin + spriteUV * uvSize;\n    vec4 spriteTexColor =texture(spriteLightTexture, atlasUV);\n    if (spriteTexColor.a < 0.001) return vec3(0.0);\n    float attenuation = spriteTexColor.a;\n    vec3 finalLight = spriteTexColor.rgb * lightColor * intensity * attenuation;\n    if(useNormalMap<0.5){\n      return baseColor * finalLight  ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n    return baseColor * finalLight * diffuse;\n}\n  vec2 getShadowMapUV(vec2 fragWorldPos) {\n    return ((fragWorldPos.xy - shadowMaskOffset.xy) * shadowMaskOffset.zw) / shadowMaskArea.zw;\n  }\n  vec2 getAmbientShadowMapUV(vec2 fragWorldPos) {\n    return ((fragWorldPos.xy - shadowMaskOffset.xy) * shadowMaskOffset.zw) / ambientShadowMaskArea.zw;\n  }\n  float getShadowBit(vec4 shadowMask, float id) {\n      int idx = int(id);\n      int channel = idx / 8;\n      int bit = idx - channel * 8;\n      int mask = int(255.0 *\n          (channel == 0 ? shadowMask.r :\n          channel == 1 ? shadowMask.g :\n          channel == 2 ? shadowMask.b : shadowMask.a));\n      return float((mask >> bit) & 1);\n  }\n  float getNumberFromVec4Array(vec4 arr[16/4], int index) {\n    int idx = index;\n    int arrIdx = idx / 4;\n    int compIdx = idx - arrIdx * 4;\n    vec4 v = arr[arrIdx];\n    float components[4];\n    components[0] = v.x;\n    components[1] = v.y;\n    components[2] = v.z;\n    components[3] = v.w;\n    return components[compIdx];\n  }\n  bool isInLightById(float lightId) {\n      if(shadowOnOff == 0.0) return true;\n      vec2 uv = getShadowMapUV(worldPos.xy);\n      vec4 shadowMask = texture(shadowMap, uv);\n      return getShadowBit(shadowMask, lightId) != 0.0 ;\n  }\n  vec4 frag () {\n      vec4 o = vec4(1, 1, 1, 1);\n        o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n      vec4 baseColor = o;\n      #if TWO_COLORED\n        baseColor.a = o.a * color.a;\n        baseColor.rgb = ((o.a - 1.0) * v_dark.a + 1.0 - o.rgb) * v_dark.rgb + o.rgb * color.rgb;\n      #else\n        baseColor = o * color;\n      #endif\n      _fragLighted = 0;\n      if(lightOnOff<0.5){\n        ALPHA_TEST(baseColor);\n        return baseColor;\n      }\n      if(ambientShadowOnOff>0.5){\n        vec2 uv = getAmbientShadowMapUV(worldPos.xy);\n        vec4 sc = texture(ambientShadowMap, uv);\n          baseColor.rgb *= sc.rgb;\n      }\n      vec3 normalVec = vec3(0.0, 0.0, 1.0);\n      vec4 normalData = vec4(0.0, 0.0, 1.0, 1.0);\n      if(useNormalMap >0.5) {\n        normalData = texture(normalMap, uv0);\n        normalVec = normalize(normalData.xyz * 2.0 - 1.0);\n      }\n      vec3 dummyColor =  vec3(1.0);\n      vec3 ambientLight = vec3(0.0);\n      vec3 valueLightInflu = vec3(0.0);\n      if(isFLoatEqual(ambientOnOffResult,1.0)){\n          ambientLight =  ambientColor.rgb * ambientIntensity;\n      }\n      int customLightIndex = 0;\n      for (int i = 0; i < 20; ++i) {\n        if (float(i) < lightCount) {\n          vec4 posData = lightPositionsArr[i];\n          vec4 colorData = lightColorsArr[i];\n          vec4 paramData = lightParamsArr[i];\n          vec4 extraData = lightExtraDataArr[i];\n          vec4 extraData2 = lightExtraDataArr2[i];\n          vec4 extraData3 = lightExtraDataArr3[i];\n          float lightType = posData.w;\n          float lightId = posData.z;\n          vec3 inputColor =(paramData.y == 0.0?baseColor.rgb:dummyColor);\n          if (lightType < 0.5) {\n            if( isInLightById(lightId)||inEditMode>0.5) {\n              valueLightInflu += calculatePointLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData, extraData2,extraData3);\n            }\n          } else if (lightType > 0.5 && lightType < 1.5) {\n            vec3 lightPos = posData.xyz;\n            float rangeX = extraData.z;\n            float rangeY = extraData.w;\n            vec2 relativePos = worldPos.xy - lightPos.xy;\n            float maxRange = max(rangeX, rangeY);\n            if (dot(relativePos, relativePos) <= maxRange * maxRange) {\n                valueLightInflu += calculateSpriteLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData, extraData2,extraData3);\n            }\n          } else if (lightType > 1.5 && lightType < 2.5) {\n            valueLightInflu += calculateParametricRegularPolygon(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData,extraData2);\n          }else if (lightType > 2.5 && lightType < 3.5) {\n            valueLightInflu += calculateParametricRectangleLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData,extraData2);\n          } else if (lightType > 3.5 && lightType < 4.5) {\n            valueLightInflu += calculateParametricCircleLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData,extraData2);\n          } else if (lightType > 4.5 && lightType < 5.5) {\n              int polygonIndex = int(getNumberFromVec4Array(customTextureIndexArr, customLightIndex));\n              vec4 prePoints[4];\n              int baseIndex = polygonIndex * 4;\n              prePoints[0] = customArr[baseIndex];\n              prePoints[1] = customArr[baseIndex + 1];\n              prePoints[2] = customArr[baseIndex + 2];\n              prePoints[3] = customArr[baseIndex + 3];\n              valueLightInflu += calculateParametricCustomPolygon(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData, prePoints,extraData2);\n              customLightIndex += 1;\n          }\n        } else {\n          break;\n        }\n      }\n      vec3 finalColor = valueLightInflu;\n      o.rgb = ambientLight * baseColor.rgb  + finalColor;\n      o.a = baseColor.a;\n      ALPHA_TEST(o);\n      return o;\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define REFLECTION_PROBE_TYPE_BLEND 3\n  #define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n      #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_SPHERE 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define LIGHT_TYPE_POINT 3.0\n  #define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n  #define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n  #define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n  #define TONE_MAPPING_ACES 0\n  #define TONE_MAPPING_LINEAR 1\n  #define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n  #ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n    #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n  #endif\n  #ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n  #endif\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\n#if TWO_COLORED\n  attribute vec4 a_color2;\n#endif\nvarying vec4 v_color;\n#if TWO_COLORED\n  varying vec4 v_dark;\n#endif\nvarying vec4 color;\nvarying vec2 uv0;\nvarying vec3 worldPos;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    worldPos = (cc_matWorld * pos).xyz;\n    pos = cc_matWorld * pos;\n  #else\n    worldPos = a_position;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n #if TWO_COLORED\n    v_dark = a_color2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  vec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n  #if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n  #else\n    return texture2D(tex, uv);\n  #endif\n  }\n  #if USE_ALPHA_TEST\n          uniform float alphaThreshold;\n  #endif\n  void ALPHA_TEST (in vec4 color) {\n    #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n    #endif\n  }\n  void ALPHA_TEST (in float alpha) {\n    #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n    #endif\n  }\n  varying vec4 color;\n  varying vec3 worldPos;\n  varying vec2 uv0;\n  #if TWO_COLORED\n    varying vec4 v_dark;\n  #endif\n  int _fragLighted = 0;\n  uniform sampler2D shadowMap;\n  uniform sampler2D normalMap;\n  uniform sampler2D spriteLightTexture;\n  uniform sampler2D ambientShadowMap;\n                 uniform vec4 lightPositionsArr[20];\n               uniform vec4 lightColorsArr[20];\n               uniform vec4 lightParamsArr[20];\n               uniform vec4 customTextureIndexArr[4];\n               uniform vec4 lightExtraDataArr[20];\n               uniform vec4 lightExtraDataArr2[20];\n               uniform vec4 lightExtraDataArr3[20];\n               uniform vec4 customArr[64];\n               uniform vec4 shadowMaskArea;\n               uniform vec4 shadowMaskOffset;\n               uniform vec4 ambientColor;\n               uniform vec4 ambientShadowMaskArea;\n               uniform float ambientShadowOnOff;\n               uniform float ambientIntensity;\n               uniform float ambientOnOffResult;\n               uniform float useNormalMap;\n               uniform float lightCount;\n               uniform float lightOnOff;\n               uniform float shadowOnOff;\n               uniform float inEditMode;\n               uniform float useAlphaHeight;\n               uniform float baseHeight;\n               uniform float heightScale;\n    uniform sampler2D cc_spriteTexture;\nfloat intPow10(float base, float fexp) {\n    float t1 = clamp(fexp, 0.0, 10.0);\n    int exponent = int(t1 + 0.5);\n    if (exponent == 0) return 1.0;\n    if (exponent == 1) return base;\n    float result = base;\n    for (int i = 1; i < 10; i++) {\n        if (i >= exponent) break;\n        result *= base;\n    }\n    return result;\n}\n  float normalizeDeg(float deg) {\n    return mod(mod(deg + 180.0, 360.0) + 360.0, 360.0) - 180.0;\n  }\n  bool inAngleRange(float deg, float start, float end) {\n    float r = mod(end - start + 360.0, 360.0);\n    if (abs(end - start) >= 359.99) return true;\n    float d = mod(deg - start + 360.0, 360.0);\n    return d <= r;\n  }\n  bool isFLoatEqual(float a, float b) {\n      return abs(a - b) < 1e-4;\n  }\nfloat calculateEffectiveHeight(vec3 normalVec, vec4 normalData) {\n    float effectiveReceiverHeight = baseHeight;\n    if (useAlphaHeight > 0.5) {\n        float alphaHeight = (normalData.a - 0.5) * heightScale;\n        effectiveReceiverHeight = baseHeight + alphaHeight;\n    } else {\n        float surfaceHeightOffset = (normalVec.z - 1.0) * heightScale;\n        effectiveReceiverHeight = baseHeight + surfaceHeightOffset;\n    }\n    return effectiveReceiverHeight;\n}\nfloat calculate3DLighting(vec3 normalVec, vec2 relPx, float effectiveReceiverHeight, float lightHeight) {\n    vec3 lightToFrag = vec3(relPx.x, relPx.y, effectiveReceiverHeight - lightHeight);\n    vec3 lightDir = normalize(-lightToFrag);\n    return max(0.0, dot(normalize(normalVec), lightDir));\n}\n  vec3 calculatePointLight(\n      vec3 normalVec,\n      vec4 normalData,\n      vec3 baseColor,\n      vec3 fragWorldPos,\n      vec4 lightPosData,\n      vec4 lightColorData,\n      vec4 lightParamData,\n      vec4 lightExtraData,\n      vec4 lightExtraData2,\n      vec4 lightExtraData3\n  ) {\n      vec3 lightWorldPos = lightPosData.xyz;\n      vec3 lightColor = lightColorData.rgb;\n      float intensity = lightParamData.x;\n      float blendMode = lightParamData.y;\n      float falloff = lightExtraData.w;\n      float innerRadius = lightExtraData.x;\n      float innerAngleStart = lightExtraData.y;\n      float innerAngleEnd = lightExtraData.z;\n      float outerAngleStart = lightExtraData2.x;\n      float outerAngleEnd = lightExtraData2.y;\n      float outerRadius = lightExtraData2.z;\n      vec2 relPxOri = fragWorldPos.xy - lightWorldPos.xy;\n      float distPx = dot(relPxOri, relPxOri);\n      if (distPx > outerRadius * outerRadius) {\n        return vec3(0.0);\n      }\n      float cosA = lightExtraData3.x;\n      float sinA = lightExtraData3.y;\n      vec2 relPx = vec2(\n        dot(relPxOri, vec2(cosA, -sinA)),\n        dot(relPxOri, vec2(sinA, cosA))\n      );\n      float t = 1.0;\n      if (distPx > innerRadius * innerRadius) {\n        float dis = sqrt(distPx);\n        t = 1.0 - smoothstep(innerRadius, outerRadius, dis);\n        t = intPow10(t, falloff);\n      }\n      float angle = atan(relPx.y, relPx.x);\n      float deg = degrees(angle);\n      deg = normalizeDeg(deg);\n      float aInnerStart = degrees(innerAngleStart);\n      float aInnerEnd = degrees(innerAngleEnd);\n      float aOuterStart = degrees(outerAngleStart);\n      float aOuterEnd =degrees (outerAngleEnd);\n      if(!inAngleRange(deg, aOuterStart, aOuterEnd)) {\n        return vec3(0.0);\n      }\n      float angleAtten = 0.0;\n      float totalAngle = abs(aOuterEnd - aOuterStart);\n      if (totalAngle >= 360.0) {\n        angleAtten = 1.0;\n      } else if (inAngleRange(deg, aInnerStart, aInnerEnd)) {\n        angleAtten = 1.0;\n      } else if (inAngleRange(deg, aOuterStart, aInnerStart)) {\n        float edgeLen = mod(aInnerStart - aOuterStart + 360.0, 360.0);\n        float s = mod(deg - aOuterStart + 360.0, 360.0) / edgeLen;\n        angleAtten = intPow10(s, falloff);\n      } else if (inAngleRange(deg, aInnerEnd, aOuterEnd)) {\n        float edgeLen = mod(aOuterEnd - aInnerEnd + 360.0, 360.0);\n        float s = mod(aOuterEnd - deg + 360.0, 360.0) / edgeLen;\n        angleAtten = intPow10(s, falloff);\n      } else {\n        angleAtten = 0.0;\n      }\n      float attenuation = t * angleAtten;\n      if (attenuation <= 0.001) {\n        return vec3(0.0);\n      };\n    _fragLighted = 1;\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation * intensity;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relPxOri, effectiveReceiverHeight, lightHeight);\n    return baseColor*lightColor * attenuation * diffuse * intensity;\n  }\n  float sdPolygon(vec2 p, float radius, float sides) {\n    float sideCount = max(3.0, floor(sides + 0.5));\n    float angleStep = 6.2831853 / sideCount;\n    float a = atan(p.y, p.x) + 3.1415926;\n    float r = length(p);\n    float segmentAngle = floor((a + angleStep * 0.5) / angleStep) * angleStep;\n    float distToEdge = r * cos(segmentAngle - a) - radius * cos(angleStep * 0.5);\n    float distToVertex = r - radius;\n    return max(distToEdge, distToVertex);\n  }\n  vec3 calculateParametricRegularPolygon(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 lightExtraData,vec4 lightExtraData2) {\n    vec3 lightPos = lightPosData.xyz;\n    vec3 lightColor = lightColorData.rgb;\n    float intensity = lightParamData.x;\n    float radius = max(0.1, lightExtraData.x);\n    float sides = max(3.0, lightExtraData.y);\n    float falloffRange = lightExtraData2.y;\n    float  falloffExponent = lightExtraData2.x;\n    vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n    float cosA = lightExtraData.z;\n    float sinA = lightExtraData.w;\n    vec2 rel = vec2(\n      dot(relativePos, vec2(cosA, -sinA)),\n      dot(relativePos, vec2(sinA, cosA))\n    );\n    float dist = length(rel);\n    float attenuationDistance =  falloffRange;\n    if (dist > (radius + attenuationDistance)) return vec3(0.0);\n    float sdDist = sdPolygon(rel, radius, sides);\n    float attenuation = 0.0;\n    if (sdDist <= 0.0) {\n      attenuation = intensity;\n    } else if (sdDist < attenuationDistance) {\n      float normalizedDist = sdDist / attenuationDistance;\n      float t = intPow10(1.0 - normalizedDist, falloffExponent);\n      attenuation = intensity * clamp(t, 0.0, 1.0);\n    }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n    return baseColor*lightColor * attenuation * diffuse;\n  }\n  float sdBox( vec2 p, vec2 b )\n  {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n  }\n  vec3 calculateParametricRectangleLight(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 lightExtraData,vec4 lightExtraData2) {\n      vec3 lightPos = lightPosData.xyz;\n      vec3 lightColor = lightColorData.rgb;\n      float intensity = lightParamData.x;\n      float width = max(0.1, lightExtraData.x);\n      float height = max(0.1, lightExtraData.y);\n      float falloffRange = lightExtraData2.y;\n      float falloffExponent = lightExtraData2.x;\n      vec2 halfSize = vec2(width * 0.5, height * 0.5);\n      vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n      float cosA = lightExtraData.z;\n      float sinA = lightExtraData.w;\n      vec2 rel = vec2(\n          dot(relativePos, vec2(cosA, -sinA)),\n          dot(relativePos, vec2(sinA, cosA))\n      );\n      float attenuationDistance =  falloffRange;\n      float maxDist = length(halfSize) + attenuationDistance;\n      if (length(rel) > maxDist) return vec3(0.0);\n      float sdDist = sdBox(rel, halfSize);\n      float attenuation = 0.0;\n      if (sdDist <= 0.0) {\n        attenuation = intensity;\n      } else if (sdDist < attenuationDistance) {\n        float normalizedDist = sdDist / attenuationDistance;\n        float t = intPow10(1.0 - normalizedDist,falloffExponent);\n        attenuation = intensity * clamp(t, 0.0, 1.0);\n      }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n      return baseColor * lightColor * attenuation * diffuse;\n  }\n  vec3 calculateParametricCircleLight(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 lightExtraData,vec4 lightExtraData2) {\n      vec3 lightPos = lightPosData.xyz;\n      vec3 lightColor = lightColorData.rgb;\n      float intensity = lightParamData.x;\n      float radius = max(0.1, lightExtraData.x);\n      float falloffRange = lightExtraData2.y;\n      float falloffExponent = lightExtraData2.x;\n      float cosA = lightExtraData.z;\n      float sinA = lightExtraData.w;\n      vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n      vec2 rel = vec2(\n          dot(relativePos, vec2(cosA, -sinA)),\n          dot(relativePos, vec2(sinA, cosA))\n      );\n      float dist = length(rel);\n      float attenuationDistance =  falloffRange;\n      float maxDist = radius + attenuationDistance;\n      if (dist > maxDist) return vec3(0.0);\n      float attenuation = 0.0;\n      if (dist <= radius) {\n        attenuation = intensity;\n      } else if (dist < maxDist) {\n        float normalizedDist = (dist - radius) / attenuationDistance;\n        float t = intPow10(1.0 - normalizedDist, falloffExponent);\n        attenuation = intensity * clamp(t, 0.0, 1.0);\n      }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n      return baseColor * lightColor * attenuation * diffuse;\n  }\n  float sdOptimizedPolygon(vec2 p, vec4 precomputedData[4], int pointCount) {\n    const float epsilon = 0.00001;\n    float minDist = 1e20;\n    for (int i = 0; i < 4; ++i) {\n      if (i >= pointCount) break;\n      vec2 a = precomputedData[i].xy;\n      vec2 edgeVec = vec2(precomputedData[i].z, precomputedData[i].w);\n      vec2 pa = p - a;\n      float edgeLengthSq = dot(edgeVec, edgeVec);\n      if (edgeLengthSq > 0.0) {\n        float h = clamp(dot(pa, edgeVec) / edgeLengthSq, 0.0, 1.0);\n        minDist = min(minDist, length(pa - edgeVec * h));\n      }\n    }\n    bool inside = false;\n    for (int i = 0; i < 4; ++i) {\n      if (i >= pointCount) break;\n      vec2 a = precomputedData[i].xy;\n      vec2 b = a + vec2(precomputedData[i].z, precomputedData[i].w);\n      if (((a.y <= p.y) && (b.y > p.y)) || ((a.y > p.y) && (b.y <= p.y))) {\n        float crossProduct = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n        if (abs(crossProduct) < epsilon) {\n          crossProduct = 0.0;\n        }\n        if (a.y < b.y) {\n          inside = inside != (crossProduct > 0.0);\n        } else {\n          inside = inside != (crossProduct < 0.0);\n        }\n      }\n    }\n    return inside ? -minDist : minDist;\n  }\nvec3 calculateParametricCustomPolygon(vec3 normalVec,vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData, vec4 extraPackedData, vec4 precomputedPoints[4],vec4 extraData2) {\n    int pointCount = int(extraPackedData.x);\n    float falloffRange = extraPackedData.y;\n    float falloffExponent = extraPackedData.z;\n    if (pointCount < 3) return vec3(0.0);\n    vec3 lightPos = lightPosData.xyz;\n    vec3 lightColor = lightColorData.rgb;\n    float intensity = lightParamData.x;\n    vec2 center = vec2(extraData2.z,extraData2.w);\n    vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n    float cosA = extraData2.x;\n    float sinA = extraData2.y;\n    vec2 fragLocalPos = vec2(\n        dot(relativePos, vec2(cosA, -sinA)),\n        dot(relativePos, vec2(sinA, cosA))\n    );\n    float maxRadius = extraPackedData.w +falloffRange ;\n    vec2 disv = fragLocalPos-center;\n    if ((disv.x*disv.x+disv.y*disv.y) > maxRadius*maxRadius) return vec3(0.0);\n    vec2 checkLocalPos = fragLocalPos;\n    bool quickInside = false;\n    for (int k = 0; k < 4; ++k) {\n      if (k >= pointCount) break;\n      vec2 a = precomputedPoints[k].xy;\n      vec2 b = a + vec2(precomputedPoints[k].z, precomputedPoints[k].w);\n      if (((a.y <= checkLocalPos.y) && (b.y > checkLocalPos.y)) ||\n        ((a.y > checkLocalPos.y) && (b.y <= checkLocalPos.y))) {\n        float crossProduct = (b.x - a.x) * (checkLocalPos.y - a.y) - (b.y - a.y) * (checkLocalPos.x - a.x);\n        if (a.y < b.y) {\n          quickInside = quickInside != (crossProduct > 0.0);\n        } else {\n          quickInside = quickInside != (crossProduct < 0.0);\n        }\n      }\n    }\n    bool isRangeZero = (falloffRange<1.0);\n    float sdDist =  0.0;\n    if(quickInside){\n      sdDist = 0.0;\n    }else{\n      if(isRangeZero){\n        sdDist  = falloffRange + 1.0;\n      }else{\n        sdDist = sdOptimizedPolygon(fragLocalPos, precomputedPoints, pointCount);\n      }\n    }\n    float attenuation= 1.0;\n    if (sdDist <= 0.0) {\n        attenuation = intensity;\n    } else if (sdDist < falloffRange) {\n        float normalizedDist = sdDist / falloffRange;\n        float t= intPow10(1.0 - normalizedDist, falloffExponent);\n        attenuation = intensity * clamp(t, 0.0, 1.0);\n    } else {\n        return vec3(0.0);\n    }\n    if(useNormalMap<0.5){\n      return baseColor * lightColor * attenuation ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n    return baseColor * lightColor * attenuation * diffuse;\n}\n vec3 calculateSpriteLight(vec3 normalVec, vec4 normalData, vec3 baseColor, vec3 fragWorldPos, vec4 lightPosData, vec4 lightColorData, vec4 lightParamData,vec4 lightExtraData,vec4 lightExtraData2,vec4 lightExtraData3) {\n    vec3 lightPos = lightPosData.xyz;\n    vec3 lightColor = lightColorData.rgb;\n    float intensity = lightParamData.x;\n    float cosA = lightExtraData.x;\n    float sinA = lightExtraData.y;\n    float rangeX = lightExtraData.z;\n    float rangeY = lightExtraData.w;\n    if (rangeX < 0.0001 || rangeY < 0.0001) return vec3(0.0);\n    vec2 relativePos = fragWorldPos.xy - lightPos.xy;\n    float maxRange = max(rangeX, rangeY);\n    if (dot(relativePos, relativePos) > maxRange * maxRange ) return vec3(0.0);\n    vec2 rel = vec2(\n        dot(relativePos, vec2(cosA, -sinA)),\n        dot(relativePos, vec2(sinA, cosA))\n    );\n    vec2 halfSizeSelf = vec2(rangeX * 0.5, rangeY * 0.5) ;\n    if(abs(rel.x) > halfSizeSelf.x || abs(rel.y) > halfSizeSelf.y) return vec3(0.0);\n    vec2 spriteUV = rel*vec2(1.0/rangeX,1.0/rangeY) + 0.5;\n    vec2 uvOrigin = lightExtraData2.xy;\n    vec2 uvSize = lightExtraData2.zw;\n    vec2 atlasUV = uvOrigin + spriteUV * uvSize;\n    vec4 spriteTexColor =texture2D(spriteLightTexture, atlasUV);\n    if (spriteTexColor.a < 0.001) return vec3(0.0);\n    float attenuation = spriteTexColor.a;\n    vec3 finalLight = spriteTexColor.rgb * lightColor * intensity * attenuation;\n    if(useNormalMap<0.5){\n      return baseColor * finalLight  ;\n    }\n    float lightHeight = lightParamData.w;\n    float effectiveReceiverHeight = calculateEffectiveHeight(normalVec, normalData);\n    float diffuse = calculate3DLighting(normalVec, relativePos, effectiveReceiverHeight, lightHeight);\n    return baseColor * finalLight * diffuse;\n}\n  vec2 getShadowMapUV(vec2 fragWorldPos) {\n    return ((fragWorldPos.xy - shadowMaskOffset.xy) * shadowMaskOffset.zw) / shadowMaskArea.zw;\n  }\n  vec2 getAmbientShadowMapUV(vec2 fragWorldPos) {\n    return ((fragWorldPos.xy - shadowMaskOffset.xy) * shadowMaskOffset.zw) / ambientShadowMaskArea.zw;\n  }\n  float getShadowBit(vec4 shadowMask, float id) {\n    int idx = int(id);\n    int channel = idx / 8;\n    int bit = idx - channel * 8;\n    float v = 0.0;\n    if (channel == 0) v = shadowMask.r;\n    else if (channel == 1) v = shadowMask.g;\n    else if (channel == 2) v = shadowMask.b;\n    else if (channel == 3) v = shadowMask.a;\n    float mask = 255.0 * v + 0.001;\n    return mod(floor(mask / intPow10(2.0, float(bit))+ 0.001), 2.0);\n  }\n  float getNumberFromVec4Array(vec4 arr[16/4], int index) {\n    int idx = index;\n    int arrIdx = idx / 4;\n    int compIdx = idx - arrIdx * 4;\n    vec4 v = vec4(0.0);\n    if (arrIdx == 0) v = arr[0];\n    else if (arrIdx == 1) v = arr[1];\n    else if (arrIdx == 2) v = arr[2];\n    else if (arrIdx == 3) v = arr[3];\n    if (compIdx == 0) return v.x;\n    else if (compIdx == 1) return v.y;\n    else if (compIdx == 2) return v.z;\n    else return v.w;\n  }\n  bool isInLightById(float lightId) {\n      if(shadowOnOff == 0.0) return true;\n      vec2 uv = getShadowMapUV(worldPos.xy);\n      vec4 shadowMask = texture2D(shadowMap, uv);\n      return getShadowBit(shadowMask, lightId) != 0.0 ;\n  }\n  vec4 frag () {\n      vec4 o = vec4(1, 1, 1, 1);\n        o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n      vec4 baseColor = o;\n      #if TWO_COLORED\n        baseColor.a = o.a * color.a;\n        baseColor.rgb = ((o.a - 1.0) * v_dark.a + 1.0 - o.rgb) * v_dark.rgb + o.rgb * color.rgb;\n      #else\n        baseColor = o * color;\n      #endif\n      _fragLighted = 0;\n      if(lightOnOff<0.5){\n        ALPHA_TEST(baseColor);\n        return baseColor;\n      }\n      if(ambientShadowOnOff>0.5){\n        vec2 uv = getAmbientShadowMapUV(worldPos.xy);\n        vec4 sc = texture2D(ambientShadowMap, uv);\n          baseColor.rgb *= sc.rgb;\n      }\n      vec3 normalVec = vec3(0.0, 0.0, 1.0);\n      vec4 normalData = vec4(0.0, 0.0, 1.0, 1.0);\n      if(useNormalMap >0.5) {\n        normalData = texture2D(normalMap, uv0);\n        normalVec = normalize(normalData.xyz * 2.0 - 1.0);\n      }\n      vec3 dummyColor =  vec3(1.0);\n      vec3 ambientLight = vec3(0.0);\n      vec3 valueLightInflu = vec3(0.0);\n      if(isFLoatEqual(ambientOnOffResult,1.0)){\n          ambientLight =  ambientColor.rgb * ambientIntensity;\n      }\n      int customLightIndex = 0;\n      for (int i = 0; i < 20; ++i) {\n        if (float(i) < lightCount) {\n          vec4 posData = lightPositionsArr[i];\n          vec4 colorData = lightColorsArr[i];\n          vec4 paramData = lightParamsArr[i];\n          vec4 extraData = lightExtraDataArr[i];\n          vec4 extraData2 = lightExtraDataArr2[i];\n          vec4 extraData3 = lightExtraDataArr3[i];\n          float lightType = posData.w;\n          float lightId = posData.z;\n          vec3 inputColor =(paramData.y == 0.0?baseColor.rgb:dummyColor);\n          if (lightType < 0.5) {\n            if( isInLightById(lightId)||inEditMode>0.5) {\n              valueLightInflu += calculatePointLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData, extraData2,extraData3);\n            }\n          } else if (lightType > 0.5 && lightType < 1.5) {\n            vec3 lightPos = posData.xyz;\n            float rangeX = extraData.z;\n            float rangeY = extraData.w;\n            vec2 relativePos = worldPos.xy - lightPos.xy;\n            float maxRange = max(rangeX, rangeY);\n            if (dot(relativePos, relativePos) <= maxRange * maxRange) {\n                valueLightInflu += calculateSpriteLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData, extraData2,extraData3);\n            }\n          } else if (lightType > 1.5 && lightType < 2.5) {\n            valueLightInflu += calculateParametricRegularPolygon(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData,extraData2);\n          }else if (lightType > 2.5 && lightType < 3.5) {\n            valueLightInflu += calculateParametricRectangleLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData,extraData2);\n          } else if (lightType > 3.5 && lightType < 4.5) {\n            valueLightInflu += calculateParametricCircleLight(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData,extraData2);\n          } else if (lightType > 4.5 && lightType < 5.5) {\n              int polygonIndex = int(getNumberFromVec4Array(customTextureIndexArr, customLightIndex));\n              vec4 prePoints[4];\n              int baseIndex = polygonIndex * 4;\n              if(customLightIndex==0)\n                  {\n                      prePoints[0] = customArr[0*4];\n                      prePoints[1] = customArr[0*4 + 1];\n                      prePoints[2] = customArr[0*4 + 2];\n                      prePoints[3] = customArr[0*4 + 3];\n                  }\n              else if(customLightIndex==1)\n                  {\n                      prePoints[0] = customArr[1*4];\n                      prePoints[1] = customArr[1*4 + 1];\n                      prePoints[2] = customArr[1*4 + 2];\n                      prePoints[3] = customArr[1*4 + 3];\n                  }\n              else if(customLightIndex==2)\n                  {\n                      prePoints[0] = customArr[2*4];\n                      prePoints[1] = customArr[2*4 + 1];\n                      prePoints[2] = customArr[2*4 + 2];\n                      prePoints[3] = customArr[2*4 + 3];\n                  }\n              else if(customLightIndex==3)\n                  {\n                      prePoints[0] = customArr[3*4];\n                      prePoints[1] = customArr[3*4 + 1];\n                      prePoints[2] = customArr[3*4 + 2];\n                      prePoints[3] = customArr[3*4 + 3];\n                  }\n              else if(customLightIndex==4)\n                  {\n                      prePoints[0] = customArr[4*4];\n                      prePoints[1] = customArr[4*4 + 1];\n                      prePoints[2] = customArr[4*4 + 2];\n                      prePoints[3] = customArr[4*4 + 3];\n                  }\n              else if(customLightIndex==5)\n                  {\n                      prePoints[0] = customArr[5*4];\n                      prePoints[1] = customArr[5*4 + 1];\n                      prePoints[2] = customArr[5*4 + 2];\n                      prePoints[3] = customArr[5*4 + 3];\n                  }\n              else if(customLightIndex==6)\n                  {\n                      prePoints[0] = customArr[6*4];\n                      prePoints[1] = customArr[6*4 + 1];\n                      prePoints[2] = customArr[6*4 + 2];\n                      prePoints[3] = customArr[6*4 + 3];\n                  }\n              else if(customLightIndex==7)\n                  {\n                      prePoints[0] = customArr[7*4];\n                      prePoints[1] = customArr[7*4 + 1];\n                      prePoints[2] = customArr[7*4 + 2];\n                      prePoints[3] = customArr[7*4 + 3];\n                  }\n              else if(customLightIndex==8)\n                  {\n                      prePoints[0] = customArr[8*4];\n                      prePoints[1] = customArr[8*4 + 1];\n                      prePoints[2] = customArr[8*4 + 2];\n                      prePoints[3] = customArr[8*4 + 3];\n                  }\n              else if(customLightIndex==9)\n                  {\n                      prePoints[0] = customArr[9*4];\n                      prePoints[1] = customArr[9*4 + 1];\n                      prePoints[2] = customArr[9*4 + 2];\n                      prePoints[3] = customArr[9*4 + 3];\n                  }\n              else if(customLightIndex==10)\n                  {\n                      prePoints[0] = customArr[10*4];\n                      prePoints[1] = customArr[10*4 + 1];\n                      prePoints[2] = customArr[10*4 + 2];\n                      prePoints[3] = customArr[10*4 + 3];\n                  }\n              else if(customLightIndex==11)\n                  {\n                      prePoints[0] = customArr[11*4];\n                      prePoints[1] = customArr[11*4 + 1];\n                      prePoints[2] = customArr[11*4 + 2];\n                      prePoints[3] = customArr[11*4 + 3];\n                  }\n              else if(customLightIndex==12)\n                  {\n                      prePoints[0] = customArr[12*4];\n                      prePoints[1] = customArr[12*4 + 1];\n                      prePoints[2] = customArr[12*4 + 2];\n                      prePoints[3] = customArr[12*4 + 3];\n                  }\n              else if(customLightIndex==13)\n                  {\n                      prePoints[0] = customArr[13*4];\n                      prePoints[1] = customArr[13*4 + 1];\n                      prePoints[2] = customArr[13*4 + 2];\n                      prePoints[3] = customArr[13*4 + 3];\n                  }\n              else if(customLightIndex==14)\n                  {\n                      prePoints[0] = customArr[14*4];\n                      prePoints[1] = customArr[14*4 + 1];\n                      prePoints[2] = customArr[14*4 + 2];\n                      prePoints[3] = customArr[14*4 + 3];\n                  }\n              else if(customLightIndex==15)\n                  {\n                      prePoints[0] = customArr[15*4];\n                      prePoints[1] = customArr[15*4 + 1];\n                      prePoints[2] = customArr[15*4 + 2];\n                      prePoints[3] = customArr[15*4 + 3];\n                  }\n              valueLightInflu += calculateParametricCustomPolygon(normalVec,normalData, inputColor, worldPos, posData, colorData, paramData, extraData, prePoints,extraData2);\n              customLightIndex += 1;\n          }\n        } else {\n          break;\n        }\n      }\n      vec3 finalColor = valueLightInflu;\n      o.rgb = ambientLight * baseColor.rgb  + finalColor;\n      o.a = baseColor.a;\n      ALPHA_TEST(o);\n      return o;\n  }\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":[]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":56,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":247}},"defines":[{"name":"USE_LOCAL","type":"boolean"},{"name":"SAMPLE_FROM_RT","type":"boolean"},{"name":"TWO_COLORED","type":"boolean"},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean"},{"name":"CC_USE_EMBEDDED_ALPHA","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"}]}],[{"passes":[{"program":"../Light2D/light-receiver|sprite-vs:vert|sprite-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"alphaThreshold":{"type":13,"value":[0.01]},"lightOnOff":{"type":13,"value":[1]},"shadowOnOff":{"type":13,"value":[0]},"ambientColor":{"type":16,"value":[1,1,1,1]},"ambientIntensity":{"type":13,"value":[0.4]},"ambientOnOffResult":{"type":13,"value":[1]},"lightCount":{"type":13,"value":[0]},"lightPositionsArr":{"type":16,"value":[0,0,0,0]},"lightColorsArr":{"type":16,"value":[0,0,0,0]},"lightParamsArr":{"type":16,"value":[0,0,0,0]},"lightExtraDataArr":{"type":16,"value":[0,0,0,0]},"lightExtraDataArr2":{"type":16,"value":[0,0,0,0]},"lightExtraDataArr3":{"type":16,"value":[0,0,0,0]},"customArr":{"type":16,"value":[0,0,0,0]},"useNormalMap":{"type":13,"value":[0]},"normalMap":{"value":"white","type":28},"useAlphaHeight":{"type":13,"value":[0]},"baseHeight":{"type":13,"value":[0]},"heightScale":{"type":13,"value":[5]},"spriteLightTexture":{"value":"white","type":28},"shadowMap":{"value":"white","type":28},"shadowMaskArea":{"type":16,"value":[0,0,0,0]},"shadowMaskOffset":{"type":16,"value":[0,0,0,0]},"inEditMode":{"type":13,"value":[1]},"customPolygonCount":{"type":13,"value":[0]},"customTextureIndexArr":{"type":16,"value":[0,0,0,0]},"ambientShadowOnOff":{"type":13,"value":[0]},"ambientShadowMap":{"value":"white","type":28},"ambientShadowMaskArea":{"type":16,"value":[0,0,0,0]}}}]}]]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["eaz5aort5LA7RCpCZIMLW2"]}],[2],0,[],[],[]],[[[9,"ambient-shadow",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true}],[[[{"dirLightAngle":300,"dirShadowOffset":-89.9},"dirShadowColor",8,[4,1795162112],"srcTexture",6,0]],11]]],0,0,[0,0],[15,6],[28,29]],[[[54,[[55,"ShadowFlow",[[56,"ShadowStage"]]],[57,"ForwardFlow",1,[[58,"ForwardStage",[[59,["default"]],[60,true,1,["default"]]]]]]]]],0,0,[],[],[]]]]
